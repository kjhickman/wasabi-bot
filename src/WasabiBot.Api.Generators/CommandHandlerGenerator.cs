using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace WasabiBot.Api.Generators;

[Generator(LanguageNames.CSharp)]
public sealed class CommandHandlerGenerator : IIncrementalGenerator
{
    private const string AttributeMetadataName = "WasabiBot.Api.Infrastructure.Discord.Interactions.CommandHandlerAttribute";

    private static readonly SymbolDisplayFormat TypeDisplayFormat = new(
        globalNamespaceStyle: SymbolDisplayGlobalNamespaceStyle.Included,
        typeQualificationStyle: SymbolDisplayTypeQualificationStyle.NameAndContainingTypesAndNamespaces,
        genericsOptions: SymbolDisplayGenericsOptions.IncludeTypeParameters,
        miscellaneousOptions: SymbolDisplayMiscellaneousOptions.ExpandNullable | SymbolDisplayMiscellaneousOptions.UseSpecialTypes);

    private static readonly DiagnosticDescriptor EntryPointNotFound = new(
        id: "WB0001",
        title: "Command handler entry point not found",
        messageFormat: "Command handler '{0}' must define an instance method named '{1}'",
        category: "Usage",
        defaultSeverity: DiagnosticSeverity.Error,
        isEnabledByDefault: true);

    private static readonly DiagnosticDescriptor InvalidEntryPointSignature = new(
        id: "WB0002",
        title: "Command handler entry point has an invalid signature",
        messageFormat: "Command handler entry point '{1}' on '{0}' must declare WasabiBot.Api.Infrastructure.Discord.Abstractions.ICommandContext as its first parameter",
        category: "Usage",
        defaultSeverity: DiagnosticSeverity.Error,
        isEnabledByDefault: true);

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var handlerResults = context.SyntaxProvider
            .ForAttributeWithMetadataName(
                AttributeMetadataName,
                static (node, _) => node is ClassDeclarationSyntax,
                static (ctx, _) => CreateCommandHandlerInfo(ctx))
            .Collect();

        var handlersWithCompilation = context.CompilationProvider.Combine(handlerResults);

        context.RegisterSourceOutput(handlersWithCompilation, static (spc, source) =>
        {
            foreach (var diagnostic in source.Right
                         .SelectMany(result => result.Diagnostics))
            {
                spc.ReportDiagnostic(diagnostic);
            }

            var infos = source.Right
                .Select(result => result.Info)
                .OfType<CommandHandlerInfo>()
                .OrderBy(info => info.CommandName, StringComparer.OrdinalIgnoreCase)
                .ToImmutableArray();

            if (infos.IsDefault)
            {
                infos = ImmutableArray<CommandHandlerInfo>.Empty;
            }

            var builder = new StringBuilder();
            builder.AppendLine("// <auto-generated />");
            builder.AppendLine("#nullable enable");
            builder.AppendLine("using Microsoft.Extensions.DependencyInjection;");
            builder.AppendLine("using Microsoft.Extensions.Hosting;");
            builder.AppendLine("using NetCord.Hosting.Services.ApplicationCommands;");
            builder.AppendLine("using NetCord.Services.ApplicationCommands;");
            builder.AppendLine("namespace WasabiBot.Api.Infrastructure.Discord;");
            builder.AppendLine();
            builder.AppendLine("internal static class DiscordCommandHandlerExtensions");
            builder.AppendLine("{");
            builder.AppendLine("    public static IServiceCollection AddDiscordCommandHandlers(this IServiceCollection services)");
            builder.AppendLine("    {");
            foreach (var info in infos)
            {
                builder.Append("        services.AddScoped<")
                    .Append(info.TypeName)
                    .AppendLine(">();");
            }
            builder.AppendLine("        return services;");
            builder.AppendLine("    }");
            builder.AppendLine();
            builder.AppendLine("    public static IHost MapDiscordCommandHandlers(this IHost app)");
            builder.AppendLine("    {");
            foreach (var info in infos)
            {
                var commandNameLiteral = Microsoft.CodeAnalysis.CSharp.SymbolDisplay.FormatLiteral(info.CommandName, quote: true);
                var descriptionLiteral = Microsoft.CodeAnalysis.CSharp.SymbolDisplay.FormatLiteral(info.Description, quote: true);

                var lambdaParameters = new List<string>
                {
                    $"{info.TypeName} handler",
                    "global::NetCord.Services.ApplicationCommands.ApplicationCommandContext ctx"
                };

                var callArguments = new List<string> { "commandContext" };

                foreach (var parameter in info.Parameters.Skip(1))
                {
                    lambdaParameters.Add($"{parameter.TypeName} {parameter.Name}");
                    callArguments.Add(parameter.Name);
                }

                builder.Append("        app.AddSlashCommand(")
                    .Append(commandNameLiteral)
                    .Append(", ")
                    .Append(descriptionLiteral)
                    .Append(", (")
                    .Append(string.Join(", ", lambdaParameters))
                    .AppendLine(") =>");
                builder.AppendLine("        {");
                builder.AppendLine("            var commandContext = new global::WasabiBot.Api.Infrastructure.Discord.Interactions.WasabiCommandContext(ctx);");
                builder.Append("            return handler.")
                    .Append(info.EntryPoint)
                    .Append('(')
                    .Append(string.Join(", ", callArguments))
                    .AppendLine(");");
                builder.AppendLine("        });");
                builder.AppendLine();
            }
            builder.AppendLine("        return app;");
            builder.AppendLine("    }");
            builder.AppendLine("}");

            spc.AddSource("CommandHandlerRegistry.g.cs", builder.ToString());
        });
    }

    private static CommandHandlerResult CreateCommandHandlerInfo(GeneratorAttributeSyntaxContext context)
    {
        if (context.TargetSymbol is not INamedTypeSymbol classSymbol)
        {
            return CommandHandlerResult.Empty;
        }

        if (context.Attributes.Length == 0)
        {
            return CommandHandlerResult.Empty;
        }

        var attribute = context.Attributes[0];

        var attributeLocation = attribute.ApplicationSyntaxReference?.GetSyntax() is AttributeSyntax attributeSyntax
            ? attributeSyntax.GetLocation()
            : classSymbol.Locations.FirstOrDefault() ?? Location.None;

        var commandContextType = context.SemanticModel.Compilation.GetTypeByMetadataName("WasabiBot.Api.Infrastructure.Discord.Abstractions.ICommandContext");
        if (commandContextType is null)
        {
            return CommandHandlerResult.Empty;
        }

        var targetTypeName = classSymbol.ToDisplayString(TypeDisplayFormat);

        var commandName = attribute.ConstructorArguments.Length > 0
            ? attribute.ConstructorArguments[0].Value as string
            : classSymbol.Name;
        var description = attribute.ConstructorArguments.Length > 1
            ? attribute.ConstructorArguments[1].Value as string ?? string.Empty
            : string.Empty;
        var entryPoint = attribute.ConstructorArguments.Length > 2 &&
                         attribute.ConstructorArguments[2].Value is string entryName
            ? entryName
            : "ExecuteAsync";

        var entryMethod = classSymbol.GetMembers()
            .OfType<IMethodSymbol>()
            .Where(m => string.Equals(m.Name, entryPoint, StringComparison.Ordinal) && !m.IsStatic)
            .ToImmutableArray();

        if (entryMethod.Length == 0)
        {
            return CommandHandlerResult.FromDiagnostic(Diagnostic.Create(EntryPointNotFound, attributeLocation, targetTypeName, entryPoint));
        }

        var entryMethodWithContext = entryMethod
            .Where(m => m.Parameters.Length > 0 && SymbolEqualityComparer.Default.Equals(m.Parameters[0].Type, commandContextType))
            .OrderByDescending(m => m.Parameters.Length)
            .ThenBy(m => m.ToDisplayString(SymbolDisplayFormat.MinimallyQualifiedFormat))
            .FirstOrDefault();

        if (entryMethodWithContext is null)
        {
            return CommandHandlerResult.FromDiagnostic(Diagnostic.Create(InvalidEntryPointSignature, attributeLocation, targetTypeName, entryPoint));
        }

        var parameters = entryMethodWithContext.Parameters
            .Select(p => new CommandParameterInfo(
                p.Type.ToDisplayString(TypeDisplayFormat),
                p.Name))
            .ToImmutableArray();

        return CommandHandlerResult.FromInfo(new CommandHandlerInfo(
            targetTypeName,
            commandName ?? classSymbol.Name,
            description,
            entryMethodWithContext.Name,
            parameters));
    }

    private sealed class CommandHandlerInfo
    {
        public CommandHandlerInfo(
            string typeName,
            string commandName,
            string description,
            string entryPoint,
            ImmutableArray<CommandParameterInfo> parameters)
        {
            TypeName = typeName;
            CommandName = commandName;
            Description = description;
            EntryPoint = entryPoint;
            Parameters = parameters;
        }

        public string TypeName { get; }
        public string CommandName { get; }
        public string Description { get; }
        public string EntryPoint { get; }
        public ImmutableArray<CommandParameterInfo> Parameters { get; }
    }

    private sealed class CommandParameterInfo
    {
        public CommandParameterInfo(string typeName, string name)
        {
            TypeName = typeName;
            Name = name;
        }

        public string TypeName { get; }
        public string Name { get; }
    }

    private readonly struct CommandHandlerResult
    {
        public CommandHandlerResult(CommandHandlerInfo? info, ImmutableArray<Diagnostic> diagnostics)
        {
            Info = info;
            Diagnostics = diagnostics;
        }

        public CommandHandlerInfo? Info { get; }

        public ImmutableArray<Diagnostic> Diagnostics { get; }

        public static CommandHandlerResult Empty => new(null, ImmutableArray<Diagnostic>.Empty);

        public static CommandHandlerResult FromInfo(CommandHandlerInfo info) =>
            new(info, ImmutableArray<Diagnostic>.Empty);

        public static CommandHandlerResult FromDiagnostic(Diagnostic diagnostic) =>
            new(null, ImmutableArray.Create(diagnostic));
    }
}
