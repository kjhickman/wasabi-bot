using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace WasabiBot.Api.Generators;

[Generator(LanguageNames.CSharp)]
public sealed class CommandHandlerGenerator : IIncrementalGenerator
{
    private const string AttributeMetadataName = "WasabiBot.Api.Infrastructure.Discord.Interactions.CommandHandlerAttribute";

    private static readonly SymbolDisplayFormat TypeDisplayFormat = new(
        globalNamespaceStyle: SymbolDisplayGlobalNamespaceStyle.Included,
        typeQualificationStyle: SymbolDisplayTypeQualificationStyle.NameAndContainingTypesAndNamespaces,
        genericsOptions: SymbolDisplayGenericsOptions.IncludeTypeParameters,
        miscellaneousOptions: SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier | SymbolDisplayMiscellaneousOptions.UseSpecialTypes);

    private static readonly DiagnosticDescriptor EntryPointNotFound = new(
        id: "WB0001",
        title: "Command handler entry point not found",
        messageFormat: "Command handler '{0}' must define an instance method named '{1}'",
        category: "Usage",
        defaultSeverity: DiagnosticSeverity.Error,
        isEnabledByDefault: true);

    private static readonly DiagnosticDescriptor InvalidEntryPointSignature = new(
        id: "WB0002",
        title: "Command handler entry point has an invalid signature",
        messageFormat: "Command handler entry point '{1}' on '{0}' must declare WasabiBot.Api.Infrastructure.Discord.Abstractions.ICommandContext as its first parameter",
        category: "Usage",
        defaultSeverity: DiagnosticSeverity.Error,
        isEnabledByDefault: true);

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var handlerResults = context.SyntaxProvider
            .ForAttributeWithMetadataName(
                AttributeMetadataName,
                static (node, _) => node is ClassDeclarationSyntax,
                static (ctx, _) => CreateCommandHandlerInfo(ctx))
            .Collect();

        var handlersWithCompilation = context.CompilationProvider.Combine(handlerResults);

        context.RegisterSourceOutput(handlersWithCompilation, static (spc, source) =>
        {
            foreach (var diagnostic in source.Right
                         .SelectMany(result => result.Diagnostics))
            {
                spc.ReportDiagnostic(diagnostic);
            }

            var infos = source.Right
                .Select(result => result.Info)
                .OfType<CommandHandlerInfo>()
                .OrderBy(info => info.CommandName, StringComparer.OrdinalIgnoreCase)
                .ToImmutableArray();

            if (infos.IsDefault)
            {
                infos = ImmutableArray<CommandHandlerInfo>.Empty;
            }

            var builder = new StringBuilder();
            builder.AppendLine("// <auto-generated />");
            builder.AppendLine("#nullable enable");
            builder.AppendLine("using Microsoft.Extensions.DependencyInjection;");
            builder.AppendLine("using Microsoft.Extensions.Hosting;");
            builder.AppendLine("using NetCord.Hosting.Services.ApplicationCommands;");
            builder.AppendLine("using NetCord.Services.ApplicationCommands;");
            builder.AppendLine("namespace WasabiBot.Api.Infrastructure.Discord;");
            builder.AppendLine();
            builder.AppendLine("internal static class DiscordCommandHandlerExtensions");
            builder.AppendLine("{");
            builder.AppendLine("    public static IServiceCollection AddDiscordCommandHandlers(this IServiceCollection services)");
            builder.AppendLine("    {");
            foreach (var info in infos)
            {
                builder.Append("        services.AddScoped<")
                    .Append(info.TypeName)
                    .AppendLine(">();");
            }
            builder.AppendLine("        return services;");
            builder.AppendLine("    }");
            builder.AppendLine();
            builder.AppendLine("    public static IHost MapDiscordCommandHandlers(this IHost app)");
            builder.AppendLine("    {");
            foreach (var info in infos)
            {
                var commandNameLiteral = Microsoft.CodeAnalysis.CSharp.SymbolDisplay.FormatLiteral(info.CommandName, quote: true);
                var descriptionLiteral = Microsoft.CodeAnalysis.CSharp.SymbolDisplay.FormatLiteral(info.Description, quote: true);

                var lambdaParameters = new List<string>
                {
                    $"{info.TypeName} handler",
                    "global::NetCord.Services.ApplicationCommands.ApplicationCommandContext ctx"
                };

                var callArguments = new List<string> { "commandContext" };

                foreach (var parameter in info.Parameters.Skip(1))
                {
                    var attributePrefix = parameter.Attributes.Length > 0 
                        ? string.Join(" ", parameter.Attributes) + " " 
                        : string.Empty;
                    
                    var paramDeclaration = $"{attributePrefix}{parameter.TypeName} {parameter.Name}";
                    if (parameter.HasNullDefault)
                    {
                        paramDeclaration += " = null";
                    }
                    lambdaParameters.Add(paramDeclaration);
                    callArguments.Add(parameter.Name);
                }

                builder.Append("        app.AddSlashCommand(")
                    .Append(commandNameLiteral)
                    .Append(", ")
                    .Append(descriptionLiteral)
                    .Append(", (")
                    .Append(string.Join(", ", lambdaParameters))
                    .AppendLine(") =>");
                builder.AppendLine("        {");
                builder.AppendLine("            var commandContext = new global::WasabiBot.Api.Infrastructure.Discord.Interactions.WasabiCommandContext(ctx);");
                builder.Append("            return handler.")
                    .Append(info.EntryPoint)
                    .Append('(')
                    .Append(string.Join(", ", callArguments))
                    .AppendLine(");");
                builder.AppendLine("        });");
                builder.AppendLine();
            }
            builder.AppendLine("        return app;");
            builder.AppendLine("    }");
            builder.AppendLine("}");

            spc.AddSource("CommandHandlerRegistry.g.cs", builder.ToString());
        });
    }

    private static CommandHandlerResult CreateCommandHandlerInfo(GeneratorAttributeSyntaxContext context)
    {
        if (context.TargetSymbol is not INamedTypeSymbol classSymbol)
        {
            return CommandHandlerResult.Empty;
        }

        if (context.Attributes.Length == 0)
        {
            return CommandHandlerResult.Empty;
        }

        var attribute = context.Attributes[0];

        var attributeLocation = attribute.ApplicationSyntaxReference?.GetSyntax() is AttributeSyntax attributeSyntax
            ? attributeSyntax.GetLocation()
            : classSymbol.Locations.FirstOrDefault() ?? Location.None;

        var commandContextType = context.SemanticModel.Compilation.GetTypeByMetadataName("WasabiBot.Api.Infrastructure.Discord.Abstractions.ICommandContext");
        if (commandContextType is null)
        {
            return CommandHandlerResult.Empty;
        }

        var targetTypeName = classSymbol.ToDisplayString(TypeDisplayFormat);

        var commandName = attribute.ConstructorArguments.Length > 0
            ? attribute.ConstructorArguments[0].Value as string
            : classSymbol.Name;
        var description = attribute.ConstructorArguments.Length > 1
            ? attribute.ConstructorArguments[1].Value as string ?? string.Empty
            : string.Empty;
        var entryPoint = attribute.ConstructorArguments.Length > 2 &&
                         attribute.ConstructorArguments[2].Value is string entryName
            ? entryName
            : "ExecuteAsync";

        var entryMethod = classSymbol.GetMembers()
            .OfType<IMethodSymbol>()
            .Where(m => string.Equals(m.Name, entryPoint, StringComparison.Ordinal) && !m.IsStatic)
            .ToImmutableArray();

        if (entryMethod.Length == 0)
        {
            return CommandHandlerResult.FromDiagnostic(Diagnostic.Create(EntryPointNotFound, attributeLocation, targetTypeName, entryPoint));
        }

        var entryMethodWithContext = entryMethod
            .Where(m => m.Parameters.Length > 0 && SymbolEqualityComparer.Default.Equals(m.Parameters[0].Type, commandContextType))
            .OrderByDescending(m => m.Parameters.Length)
            .ThenBy(m => m.ToDisplayString(SymbolDisplayFormat.MinimallyQualifiedFormat))
            .FirstOrDefault();

        if (entryMethodWithContext is null)
        {
            return CommandHandlerResult.FromDiagnostic(Diagnostic.Create(InvalidEntryPointSignature, attributeLocation, targetTypeName, entryPoint));
        }

        var parameters = entryMethodWithContext.Parameters
            .Select(p =>
            {
                var attributes = p.GetAttributes()
                    .Select(attr => FormatAttribute(attr))
                    .Where(s => !string.IsNullOrEmpty(s))
                    .ToImmutableArray();

                return new CommandParameterInfo(
                    p.Type.ToDisplayString(TypeDisplayFormat),
                    p.Name,
                    p.HasExplicitDefaultValue && p.ExplicitDefaultValue is null,
                    attributes);
            })
            .ToImmutableArray();

        return CommandHandlerResult.FromInfo(new CommandHandlerInfo(
            targetTypeName,
            commandName ?? classSymbol.Name,
            description,
            entryMethodWithContext.Name,
            parameters));
    }

    private static string FormatAttribute(AttributeData attribute)
    {
        var attributeClass = attribute.AttributeClass;
        if (attributeClass is null)
        {
            return string.Empty;
        }

        var name = attributeClass.ToDisplayString(TypeDisplayFormat);

        // Remove "Attribute" suffix if present
        if (name.EndsWith("Attribute"))
        {
            name = name.Substring(0, name.Length - "Attribute".Length);
        }

        var builder = new StringBuilder();
        builder.Append('[').Append(name);

        var hasArguments = false;

        // Constructor arguments
        if (attribute.ConstructorArguments.Length > 0)
        {
            builder.Append('(');
            hasArguments = true;

            for (int i = 0; i < attribute.ConstructorArguments.Length; i++)
            {
                if (i > 0) builder.Append(", ");
                builder.Append(FormatTypedConstant(attribute.ConstructorArguments[i]));
            }
        }

        // Named arguments
        if (attribute.NamedArguments.Length > 0)
        {
            if (!hasArguments)
            {
                builder.Append('(');
                hasArguments = true;
            }
            else
            {
                builder.Append(", ");
            }

            for (int i = 0; i < attribute.NamedArguments.Length; i++)
            {
                if (i > 0) builder.Append(", ");
                var namedArg = attribute.NamedArguments[i];
                builder.Append(namedArg.Key).Append(" = ").Append(FormatTypedConstant(namedArg.Value));
            }
        }

        if (hasArguments)
        {
            builder.Append(')');
        }

        builder.Append(']');
        return builder.ToString();
    }

    private static string FormatTypedConstant(TypedConstant constant)
    {
        if (constant.IsNull)
        {
            return "null";
        }

        if (constant.Kind == TypedConstantKind.Array)
        {
            var elements = constant.Values.Select(FormatTypedConstant);
            return $"new[] {{ {string.Join(", ", elements)} }}";
        }

        if (constant.Type?.TypeKind == TypeKind.Enum)
        {
            return $"{constant.Type.ToDisplayString(TypeDisplayFormat)}.{constant.Value}";
        }

        if (constant.Value is string stringValue)
        {
            return Microsoft.CodeAnalysis.CSharp.SymbolDisplay.FormatLiteral(stringValue, quote: true);
        }

        if (constant.Value is bool boolValue)
        {
            return boolValue ? "true" : "false";
        }

        return constant.Value?.ToString() ?? "null";
    }

    private sealed class CommandHandlerInfo
    {
        public CommandHandlerInfo(
            string typeName,
            string commandName,
            string description,
            string entryPoint,
            ImmutableArray<CommandParameterInfo> parameters)
        {
            TypeName = typeName;
            CommandName = commandName;
            Description = description;
            EntryPoint = entryPoint;
            Parameters = parameters;
        }

        public string TypeName { get; }
        public string CommandName { get; }
        public string Description { get; }
        public string EntryPoint { get; }
        public ImmutableArray<CommandParameterInfo> Parameters { get; }
    }

    private sealed class CommandParameterInfo
    {
        public CommandParameterInfo(string typeName, string name, bool hasNullDefault, ImmutableArray<string> attributes)
        {
            TypeName = typeName;
            Name = name;
            HasNullDefault = hasNullDefault;
            Attributes = attributes;
        }

        public string TypeName { get; }
        public string Name { get; }
        public bool HasNullDefault { get; }
        public ImmutableArray<string> Attributes { get; }
    }

    private readonly struct CommandHandlerResult
    {
        public CommandHandlerResult(CommandHandlerInfo? info, ImmutableArray<Diagnostic> diagnostics)
        {
            Info = info;
            Diagnostics = diagnostics;
        }

        public CommandHandlerInfo? Info { get; }

        public ImmutableArray<Diagnostic> Diagnostics { get; }

        public static CommandHandlerResult Empty => new(null, ImmutableArray<Diagnostic>.Empty);

        public static CommandHandlerResult FromInfo(CommandHandlerInfo info) =>
            new(info, ImmutableArray<Diagnostic>.Empty);

        public static CommandHandlerResult FromDiagnostic(Diagnostic diagnostic) =>
            new(null, ImmutableArray.Create(diagnostic));
    }
}
