name: Deploy

on:
  workflow_call:
    inputs:
      environment:
        description: Environment name (e.g., staging, prod).
        required: true
        type: string
    secrets:
      GH_ACTIONS_AWS_ROLE:
        required: true
      NEON_API_KEY:
        required: false

permissions:
  contents: read
  id-token: write

env:
  DOTNET_VERSION: 9.0.x
  AWS_REGION: us-east-1
  TARGET_ENV: ${{ inputs.environment }}

jobs:
  test:
    name: Run tests
    runs-on: ubuntu-24.04-arm
    steps:
      - name: Checkout
        uses: actions/checkout@v5
        with:
          fetch-depth: 1

      - name: Setup .NET
        uses: actions/setup-dotnet@v5
        with:
          dotnet-version: ${{ env.DOTNET_VERSION }}
          cache: true
          cache-dependency-path: |
            **/*.csproj
            **/*.props

      - name: Restore
        run: dotnet restore WasabiBot.slnx

      - name: Test
        run: dotnet test --configuration Release --no-restore --verbosity minimal

  build_image:
    name: Build & push image
    runs-on: ubuntu-24.04-arm
    needs: test
    outputs:
      image_repo: ${{ steps.meta.outputs.repo }}
      image_tag: ${{ steps.meta.outputs.tag }}
      image_uri: ${{ steps.meta.outputs.uri }}
      image_full_tag: ${{ steps.meta.outputs.full_tag }}
      image_digest: ${{ steps.describe-image.outputs.digest }}
      image_ref: ${{ steps.describe-image.outputs.image }}
    steps:
      - name: Checkout
        uses: actions/checkout@v5
        with:
          fetch-depth: 1

      - name: Setup build environment
        id: env_setup
        uses: ./.github/actions/workflow-setup
        with:
          configure-aws: 'true'
          role-to-assume: ${{ secrets.GH_ACTIONS_AWS_ROLE }}
          aws-region: ${{ env.AWS_REGION }}
          login-ecr: 'true'

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
        with:
          driver: docker-container

      - name: Set image metadata
        id: meta
        run: |
          echo "::group::Compute image metadata"
          target_env="${{ env.TARGET_ENV }}"
          repo="wasabi-bot/wasabi-bot-api-$target_env"
          image_tag="${GITHUB_SHA::12}"
          image_uri="${{ steps.env_setup.outputs.ecr-registry }}/$repo"
          cache_ref="$image_uri:buildcache"
          echo "repo=$repo" >> "$GITHUB_OUTPUT"
          echo "tag=$image_tag" >> "$GITHUB_OUTPUT"
          echo "uri=$image_uri" >> "$GITHUB_OUTPUT"
          echo "full_tag=$image_uri:$image_tag" >> "$GITHUB_OUTPUT"
          echo "cache_ref=$cache_ref" >> "$GITHUB_OUTPUT"
          echo "::notice title=Image Repository::$repo"
          echo "::notice title=Image Tag::$image_tag"
          echo "::endgroup::"

      - name: Build & push image
        id: build-image
        uses: docker/build-push-action@v6
        with:
          context: .
          file: src/WasabiBot.Api/Dockerfile
          push: true
          platforms: linux/arm64
          tags: |
            ${{ steps.meta.outputs.full_tag }}
            ${{ steps.meta.outputs.uri }}:latest
          cache-from: |
            type=registry,ref=${{ steps.meta.outputs.cache_ref }}
          cache-to: |
            type=registry,ref=${{ steps.meta.outputs.cache_ref }},mode=max

      - name: Capture digest
        id: describe-image
        run: |
          digest="${{ steps.build-image.outputs.digest }}"
          if [ -z "$digest" ]; then
            echo "Image digest not available from build step" >&2
            exit 1
          fi
          echo "digest=$digest" >> "$GITHUB_OUTPUT"
          echo "image=${{ steps.meta.outputs.uri }}@$digest" >> "$GITHUB_OUTPUT"

  tf_plan:
    name: Terraform plan
    runs-on: ubuntu-24.04-arm
    needs: build_image
    env:
      TF_VAR_image_digest: ${{ needs.build_image.outputs.image_digest }}
      NEON_API_KEY: ${{ secrets.NEON_API_KEY }}
      TF_PLUGIN_CACHE_DIR: ~/.terraform.d/plugin-cache
    defaults:
      run:
        working-directory: infra/envs/${{ env.TARGET_ENV }}
    steps:
      - name: Checkout
        uses: actions/checkout@v5
        with:
          fetch-depth: 1

      - name: Setup environment
        uses: ./.github/actions/workflow-setup
        with:
          configure-aws: 'true'
          role-to-assume: ${{ secrets.GH_ACTIONS_AWS_ROLE }}
          aws-region: ${{ env.AWS_REGION }}
          configure-terraform: 'true'

      - name: Prepare Terraform plugin cache
        run: mkdir -p "$TF_PLUGIN_CACHE_DIR"

      - name: Restore Terraform plugin cache
        uses: actions/cache@v4
        with:
          path: ${{ env.TF_PLUGIN_CACHE_DIR }}
          key: terraform-plugin-${{ runner.os }}-${{ env.TARGET_ENV }}-${{ hashFiles('infra/envs/**/*.terraform.lock.hcl') }}
          restore-keys: |
            terraform-plugin-${{ runner.os }}-${{ env.TARGET_ENV }}-
            terraform-plugin-${{ runner.os }}-

      - name: Restore Terraform modules
        uses: actions/cache@v4
        with:
          path: infra/envs/${{ env.TARGET_ENV }}/.terraform
          key: terraform-modules-${{ runner.os }}-${{ env.TARGET_ENV }}-${{ hashFiles('infra/envs/**/*.terraform.lock.hcl') }}
          restore-keys: |
            terraform-modules-${{ runner.os }}-${{ env.TARGET_ENV }}-
            terraform-modules-${{ runner.os }}-

      - name: Terraform init
        run: terraform init -input=false

      - name: Terraform validate
        run: terraform validate

      - name: Terraform plan
        run: terraform plan -input=false -out=tfplan

      - name: Summarize plan
        run: |
          echo "::notice title=Terraform Plan::Terraform plan for ${{ env.TARGET_ENV }} created"

      - name: Show plan (summary)
        run: terraform show -no-color tfplan | head -n 200

      - name: Upload plan artifact
        uses: actions/upload-artifact@v4
        with:
          name: terraform-plan-${{ env.TARGET_ENV }}
          path: infra/envs/${{ env.TARGET_ENV }}/tfplan
          retention-days: 1

  tf_apply:
    name: Terraform apply
    runs-on: ubuntu-24.04-arm
    needs: [tf_plan, build_image]
    environment: ${{ inputs.environment }}
    env:
      TF_VAR_image_digest: ${{ needs.build_image.outputs.image_digest }}
      NEON_API_KEY: ${{ secrets.NEON_API_KEY }}
      TF_PLUGIN_CACHE_DIR: ~/.terraform.d/plugin-cache
    defaults:
      run:
        working-directory: infra/envs/${{ env.TARGET_ENV }}
    steps:
      - name: Checkout
        uses: actions/checkout@v5
        with:
          fetch-depth: 1

      - name: Setup environment
        uses: ./.github/actions/workflow-setup
        with:
          configure-aws: 'true'
          role-to-assume: ${{ secrets.GH_ACTIONS_AWS_ROLE }}
          aws-region: ${{ env.AWS_REGION }}
          configure-terraform: 'true'

      - name: Prepare Terraform plugin cache
        run: mkdir -p "$TF_PLUGIN_CACHE_DIR"

      - name: Restore Terraform plugin cache
        uses: actions/cache@v4
        with:
          path: ${{ env.TF_PLUGIN_CACHE_DIR }}
          key: terraform-plugin-${{ runner.os }}-${{ env.TARGET_ENV }}-${{ hashFiles('infra/envs/**/*.terraform.lock.hcl') }}
          restore-keys: |
            terraform-plugin-${{ runner.os }}-${{ env.TARGET_ENV }}-
            terraform-plugin-${{ runner.os }}-

      - name: Restore Terraform modules
        uses: actions/cache@v4
        with:
          path: infra/envs/${{ env.TARGET_ENV }}/.terraform
          key: terraform-modules-${{ runner.os }}-${{ env.TARGET_ENV }}-${{ hashFiles('infra/envs/**/*.terraform.lock.hcl') }}
          restore-keys: |
            terraform-modules-${{ runner.os }}-${{ env.TARGET_ENV }}-
            terraform-modules-${{ runner.os }}-

      - name: Download plan artifact
        uses: actions/download-artifact@v4
        with:
          name: terraform-plan-${{ env.TARGET_ENV }}
          path: infra/envs/${{ env.TARGET_ENV }}

      - name: Terraform init
        run: terraform init -input=false

      - name: Terraform apply
        run: terraform apply -input=false -auto-approve tfplan

      - name: Summarize apply
        run: echo "::notice title=Terraform Apply::Infrastructure applied for ${{ env.TARGET_ENV }}"

  migrate:
    name: Run migrations
    runs-on: ubuntu-24.04-arm
    needs: test
    environment: ${{ inputs.environment }}
    steps:
      - name: Checkout
        uses: actions/checkout@v5
        with:
          fetch-depth: 1

      - name: Setup environment
        uses: ./.github/actions/workflow-setup
        with:
          configure-aws: 'true'
          role-to-assume: ${{ secrets.GH_ACTIONS_AWS_ROLE }}
          aws-region: ${{ env.AWS_REGION }}
      
      - name: Resolve connection string
        run: |
          param_name="/wasabi-bot/${{ env.TARGET_ENV }}/NeonDbConnectionString"
          conn=$(aws ssm get-parameter \
            --name "$param_name" \
            --with-decryption \
            --query 'Parameter.Value' \
            --output text)
          if [ -z "$conn" ]; then
            echo "Failed to resolve connection string from SSM parameter $param_name" >&2
            exit 1
          fi
          echo "ConnectionStrings__wasabi-db=$conn" >> "$GITHUB_ENV"

      - name: Setup .NET
        uses: actions/setup-dotnet@v5
        with:
          dotnet-version: ${{ env.DOTNET_VERSION }}

      - name: Restore (migrations project)
        run: dotnet restore WasabiBot.slnx

      - name: Build migrations project
        run: dotnet build src/WasabiBot.Migrations/WasabiBot.Migrations.csproj --configuration Release --no-restore

      - name: Apply migrations
        run: dotnet run --project src/WasabiBot.Migrations/WasabiBot.Migrations.csproj --configuration Release --no-build
